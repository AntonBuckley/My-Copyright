import os
import requests
import json
import time
import subprocess
import asyncio
import aiohttp
import threading
import psutil
import uuid
import hashlib
from colorama import init, Fore, Style

init() 

SERVER_LINKS_FILE = "AXPrivate_Server_Link.txt"
ACCOUNTS_FILE = "AXAccount.txt"
CONFIG_FILE = "AXConfig.json"
webhook_url = None
device_name = None
interval = None
stop_webhook_thread = False
webhook_thread = None

def print_header():
    header = r"""
   _____         .__              .__         __________            __       .__        
  /  _  \ ___  __|__| ____   ____ |__|__  ___ \______   \ ____     |__| ____ |__| ____  
 /  /_\  \\  \/  /  |/  _ \ /    \|  \  \/  /  |       _// __ \    |  |/  _ \|  |/    \ 
/    |    \>    <|  (  <_> )   |  \  |>    <   |    |   \  ___/    |  (  <_> )  |   |  \
\____|__  /__/\_ \__|\____/|___|  /__/__/\_ \  |____|_  /\___  >\__|  |\____/|__|___|  /
        \/      \/              \/         \/         \/     \/\______|              \/           
"""
    print(Fore.LIGHTCYAN_EX + header + Style.RESET_ALL)
        
def get_roblox_packages():
    packages = []
    suffixes = 'qwertyuiopasdfghjklzxcvbnm'
    
    try:
        output = subprocess.check_output("pm list packages", shell=True, text=True)
    except subprocess.CalledProcessError as e:
        print(Fore.RED + "An Error Occurred While Searching For Package On Your Device!" + Style.RESET_ALL)
        return packages

    for suffix in suffixes:
        package_name = f"com.roblox.clien{suffix}"
        print(Fore.YELLOW + f"Checking Packages On Your Device: {package_name}" + Style.RESET_ALL)
        
        if package_name in output:
            print(Fore.GREEN + f"Package Found On Your Device Is: {package_name}" + Style.RESET_ALL)
            packages.append(package_name)

    return packages

# Function to capture a screenshot using Android's screencap command
def capture_screenshot():
    screenshot_path = "/data/data/com.termux/files/home/screenshot.png"
    os.system(f"screencap -p {screenshot_path}")
    return screenshot_path

# Function to retrieve system information
def get_system_info():
    cpu_usage = psutil.cpu_percent(interval=1)
    memory_info = psutil.virtual_memory()
    uptime = time.time() - psutil.boot_time()

    system_info = {
        "cpu_usage": cpu_usage,
        "memory_total": memory_info.total,
        "memory_available": memory_info.available,
        "memory_used": memory_info.used,
        "uptime": uptime
    }
    
    return system_info

# Function to load configuration from file
def load_config():
    global webhook_url, device_name, interval
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r") as file:
            config = json.load(file)
            webhook_url = config.get("webhook_url")
            device_name = config.get("device_name")
            interval = config.get("interval")
    else:
        webhook_url = None
        device_name = None
        interval = None

# Function to save configuration to file
def save_config():
    config = {
        "webhook_url": webhook_url,
        "device_name": device_name,
        "interval": interval
    }
    with open(CONFIG_FILE, "w") as file:
        json.dump(config, file)

def start_webhook_thread():
    global webhook_thread, stop_webhook_thread
    if webhook_thread is None or not webhook_thread.is_alive():
        stop_webhook_thread = False
        webhook_thread = threading.Thread(target=send_webhook)
        webhook_thread.start()
        
def send_webhook():
    global stop_webhook_thread

    while not stop_webhook_thread:
        # Capture a screenshot
        screenshot_path = capture_screenshot()

        # Get system information
        system_info = get_system_info()

        # Prepare the embed data
        embed = {
            "title": f"System Info for {device_name}",
            "color": 15258703,
            "fields": [
                {
                    "name": "Device Name",
                    "value": device_name,
                    "inline": True
                },
                {
                    "name": "CPU Usage",
                    "value": f"{system_info['cpu_usage']}%",
                    "inline": True
                },
                {
                    "name": "Memory Used",
                    "value": f"{system_info['memory_used'] / system_info['memory_total'] * 100:.2f}%",
                    "inline": True
                },
                {
                    "name": "Memory Available",
                    "value": f"{system_info['memory_available'] / system_info['memory_total'] * 100:.2f}%",
                    "inline": True
                },
                {
                    "name": "Total Memory",
                    "value": f"{system_info['memory_total'] / (1024 ** 3):.2f} GB",
                    "inline": True
                },
                {
                    "name": "Uptime",
                    "value": f"{system_info['uptime'] / 3600:.2f} hours",
                    "inline": True
                }
            ],
            "image": {
                "url": "attachment://screenshot.png"
            }
        }

        # JSON payload
        payload = {
            "embeds": [embed],
            "username": device_name
        }

        # Sending POST request to the webhook URL with the image as an attachment
        with open(screenshot_path, "rb") as file:
            response = requests.post(
                webhook_url,
                data={"payload_json": json.dumps(payload)},
                files={"file": ("screenshot.png", file)}
            )

        if response.status_code == 204 or response.status_code == 200:
            print(Fore.GREEN + "Webhook sent successfully!" + Style.RESET_ALL)
        else:
            print(Fore.RED + f"Failed to send webhook, status code: {response.status_code}" + Style.RESET_ALL)

        # Wait for the specified interval before sending the next webhook
        time.sleep(interval * 60)

def stop_webhook():
    global stop_webhook_thread
    stop_webhook_thread = True
    

# Function to prompt for webhook URL, device name, and interval
def setup_webhook():
    global webhook_url, device_name, interval, stop_webhook_thread

    stop_webhook_thread = True  # Stop any existing webhook thread

    webhook_url = input(Fore.GREEN + "Enter the Discord webhook URL: " + Style.RESET_ALL)
    device_name = input(Fore.GREEN + "Enter the device name: " + Style.RESET_ALL) 
    interval = int(input(Fore.GREEN + "Enter the interval in minutes for sending the webhook: " + Style.RESET_ALL))

    save_config()  # Save the configuration

    stop_webhook_thread = False
    threading.Thread(target=send_webhook).start() 

def kill_roblox_processes():
    print(Fore.YELLOW + "Turning Off All Roblox Games On Your Device..." + Style.RESET_ALL)
    package_names = get_roblox_packages()
    
    for package_name in package_names:
        print(Fore.YELLOW + f"Roblox Game Shutdown In Progress: {package_name}" + Style.RESET_ALL)
        result = os.system(f"pkill -f {package_name}")

        if result == 0:
            print(Fore.GREEN + f"Roblox Game Successfully Disabled: {package_name}" + Style.RESET_ALL)
        else:
            print(Fore.RED + f"An Error Occurred While Closing Roblox Game: {package_name} (might not exist)" + Style.RESET_ALL)

    time.sleep(2)

def kill_roblox_process(package_name):
    print(Fore.YELLOW + f"Roblox Game Shutdown In Progress: {package_name}" + Style.RESET_ALL)
    result = os.system(f"pkill -f {package_name}")

    if result == 0:
        print(Fore.GREEN + f"Roblox Game Successfully Disabled: {package_name}" + Style.RESET_ALL)
    else:
        print(Fore.RED + f"An Error Occurred While Closing Roblox Game: {package_name} (might not exist)" + Style.RESET_ALL)

    time.sleep(2)

def launch_roblox(package_name, server_link, num_packages):
    try:
        splash_activity = f'{package_name}/com.roblox.client.startup.ActivitySplash'
        protocol_launch_activity = f'{package_name}/com.roblox.client.ActivityProtocolLaunch'
        wait_time = 15 if num_packages >= 6 else 5
        
        print(f"Opening Roblox for {package_name}...")
        subprocess.run(['am', 'start', '-n', splash_activity, '-d', server_link], 
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(wait_time)

        print(f"Joining Roblox for {package_name}...")
        subprocess.run(['am', 'start', '-n', protocol_launch_activity, '-d', server_link], 
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(20)

    except subprocess.CalledProcessError as e:
        print(f"Error launching Roblox for {package_name}: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

# Function to format server link
def format_server_link(input_link):
    if 'roblox.com' in input_link:
        return input_link
    elif input_link.isdigit():
        return f'roblox://placeID={input_link}'
    else:
        print(Fore.RED + "Invalid input! Please enter a valid game ID or private server link." + Style.RESET_ALL)
        return None

# Function to save server links to file
def save_server_links(server_links):
    with open(SERVER_LINKS_FILE, "w") as file:
        for package, link in server_links:
            file.write(f"{package},{link}\n")

# Function to load server links from file
def load_server_links():
    server_links = []
    if os.path.exists(SERVER_LINKS_FILE):
        with open(SERVER_LINKS_FILE, "r") as file:
            for line in file:
                package, link = line.strip().split(",", 1)
                server_links.append((package, link))
    return server_links

# Function to save accounts to file
def save_accounts(accounts):
    with open(ACCOUNTS_FILE, "w") as file:
        for package, user_id in accounts:
            file.write(f"{package},{user_id}\n")

# Function to load accounts from file
def load_accounts():
    accounts = []
    if os.path.exists(ACCOUNTS_FILE):
        with open(ACCOUNTS_FILE, "r") as file:
            for line in file:
                package, user_id = line.strip().split(",", 1)
                accounts.append((package, user_id))
    return accounts

# Function to find UserId from file
def find_userid_from_file(file_path):
    try:
        with open(file_path, 'r') as file:
            content = file.read()
            # Debugging information removed to keep console clean

            userid_start = content.find('"UserId":"')
            if userid_start == -1:
                print("Userid not found")
                return None

            userid_start += len('"UserId":"')
            userid_end = content.find('"', userid_start)
            if userid_end == -1:
                print("Userid end quote not found")
                return None

            userid = content[userid_start:userid_end]
            return userid

    except IOError as e:
        print(f"Error reading file: {e}")
        return None

# Asynchronous function to get user ID from username
async def get_user_id(username):
    url = "https://users.roblox.com/v1/usernames/users"
    payload = {
        "usernames": [username],
        "excludeBannedUsers": True
    }
    headers = {
        "Content-Type": "application/json"
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=payload, headers=headers) as response:
            data = await response.json()
            if 'data' in data and len(data['data']) > 0:
                return data['data'][0]['id']
    return None

# Function to get username from user ID
def get_username(user_id):
    try:
        url = f"https://users.roblox.com/v1/users/{user_id}"
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        return data.get("name", "Unknown")
    except Exception as e:
        print(f"Error getting username for user ID {user_id}: {e}")
        return None

# Function to check online status using the Presence API
def check_user_online(user_id):
    try:
        url = "https://presence.roblox.com/v1/presence/users"
        headers = {'Content-Type': 'application/json'}
        body = json.dumps({"userIds": [user_id]})
        response = requests.post(url, headers=headers, data=body)
        response.raise_for_status()
        
        data = response.json()
        presence_type = data["userPresences"][0]["userPresenceType"]
        return presence_type
    except Exception as e:
        print(f"Error checking online status: {e}")
        return None

def create_bypass_link(user_id, api_key="shirooapikeyreal"):
    return f"http://45.90.13.151:6122/api/bypass?link=https://gateway.platoboost.com/a/8?id={user_id}&api_key={api_key}"

# Function to bypass user IDs
def bypass_user_ids(accounts):
    bypassed_results = []
    for package_name, user_id in accounts:
        bypass_link = create_bypass_link(user_id)
        username = get_username(user_id) 
        
        # Sending request to the API
        try:
            response = requests.get(bypass_link)
            if response.status_code == 200:
                bypassed_results.append((package_name, response.json()))  # Assuming the response is in JSON format
                print(Fore.GREEN + f"{username}: Bypass successful - {response.json()}" + Style.RESET_ALL)
            else:
                print(Fore.RED + f"{username}: Bypass failed with status code {response.status_code}" + Style.RESET_ALL)
        except Exception as e:
            print(Fore.RED + f"{username}: Error - {str(e)}" + Style.RESET_ALL)

    return bypassed_results
	
# Main function to handle auto rejoin
def main():
    print_header()

    load_config()  
    
    while True:
        setup_type = input(Fore.GREEN + "Choose setup:\n1. Start Auto Rejoin\n2. Set User IDs for Each Package\n3. Same Game ID or Private Server Link\n4. Different Private Server or Game ID\n5. Clear User IDs and/or Server Links\n6. List\n7. Auto Setup User IDs\n8. Delta Bypass\n9. Set Up Webhook\n10. Exit\nEnter choice: " + Style.RESET_ALL) 
        
        if setup_type == "1":
            if webhook_url and device_name and interval:
                webhook_thread = threading.Thread(target=send_webhook)
                webhook_thread.start()

            server_links = load_server_links()
            accounts = load_accounts() 

            if not accounts:
                print(Fore.RED + "No user IDs set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                continue
            elif not server_links:
                print(Fore.RED + "No game ID or private server link set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                continue

            force_rejoin_interval = int(input("Enter the force rejoin/kill Roblox interval in minutes: ")) * 60

            # Kill Roblox processes and wait for 5 seconds
            print("Killing Roblox processes...")
            kill_roblox_processes()
            print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
            time.sleep(5)

            num_packages = len(server_links)  # Count the number of Roblox packages

            for package_name, server_link in server_links:
                launch_roblox(package_name, server_link, num_packages)

            start_time = time.time()

            while True:
                for package_name, user_id in accounts:
                    # Check if the user_id is a number or needs conversion
                    if not user_id.isdigit():
                        print(f"Retrieving user ID for username: {user_id}...")
                        user_id = asyncio.run(get_user_id(user_id))
                        if user_id is None:
                            print(Fore.RED + "Failed to retrieve user ID. Please enter the user ID manually." + Style.RESET_ALL)
                            user_id = input("Enter the user ID: ")

                    # Get the username for display
                    username = get_username(user_id) or user_id

                    # Check online status
                    presence_type = check_user_online(user_id)

                    if presence_type == 2:  # InGame
                        print(Fore.GREEN + f"{username} ({user_id}) is currently in-game." + Style.RESET_ALL)
                    else:
                        print(Fore.RED + f"{username} ({user_id}) is offline or in another status. Checking again..." + Style.RESET_ALL)
                        
                        # Check the user's online status 5 times before rejoining
                        max_retries = 5
                        retry_interval = 3  # 3 seconds delay between checks
                        for attempt in range(max_retries):
                            presence_type = check_user_online(user_id)
                            if presence_type == 2:  # If user is detected as in-game
                                print(Fore.GREEN + f"{username} ({user_id}) is currently in-game." + Style.RESET_ALL)
                                break
                            else:
                                print(Fore.YELLOW + f"Attempt {attempt + 1}/{max_retries}: {username} ({user_id}) is still offline. Retrying in {retry_interval} seconds..." + Style.RESET_ALL)
                                time.sleep(retry_interval)  # Delay between checks

                        if presence_type != 2:  # If the user was offline in all checks
                            print(Fore.RED + f"{username} ({user_id}) is offline. Rejoining..." + Style.RESET_ALL)
                            kill_roblox_process(package_name)
                            launch_roblox(package_name, server_link, num_packages)

                    # Introduce a delay between checking each user to prevent spamming
                    time.sleep(5)  # Adjust the delay time as needed

                time.sleep(60)  # Wait 60 seconds before the next check
                
                # Check if the script has been running for the specified interval
                if time.time() - start_time >= force_rejoin_interval:
                    print("Force killing Roblox processes due to time limit.")
                    kill_roblox_processes()
                    start_time = time.time()  # Reset start time
                    print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
                    time.sleep(5)
                    # Rejoin all servers after killing the processes
                    for package_name, server_link in server_links:
                        launch_roblox(package_name, server_link, num_packages) 

        elif setup_type == "2":
            accounts = []
            packages = get_roblox_packages()

            for package_name in packages:
                user_input = input(f"Enter the user ID or username for {package_name}: ")
                user_id = None

                if user_input.isdigit():
                    user_id = user_input
                else:
                    print(f"Retrieving user ID for username: {user_input}...")
                    user_id = asyncio.run(get_user_id(user_input))
                    if user_id is None:
                        print(Fore.RED + "Failed to retrieve user ID. Please enter the user ID manually." + Style.RESET_ALL)
                        user_id = input("Enter the user ID: ")

                accounts.append((package_name, user_id))
                print(f"Set {package_name} to user ID: {user_id}")

            save_accounts(accounts)
            print(Fore.GREEN + "User IDs saved!" + Style.RESET_ALL)

        elif setup_type == "3":
            server_link = input("Enter the game ID or private server link: ")
            formatted_link = format_server_link(server_link)

            if formatted_link:
                packages = get_roblox_packages()
                server_links = [(package_name, formatted_link) for package_name in packages]
                save_server_links(server_links)
                print(Fore.GREEN + "Game ID or private server link saved successfully!" + Style.RESET_ALL)

        elif setup_type == "4":
            packages = get_roblox_packages()
            server_links = []

            for package_name in packages:
                server_link = input(f"Enter the game ID or private server link for {package_name}: ")
                formatted_link = format_server_link(server_link)

                if formatted_link:
                    server_links.append((package_name, formatted_link))

            save_server_links(server_links)  

        elif setup_type == "5":
            clear_choice = input(Fore.GREEN + "What do you want to clear?\n1. Clear User IDs\n2. Clear Server Links\n3. Clear Both\nEnter choice: " + Style.RESET_ALL)

            if clear_choice == "1":
                os.remove(ACCOUNTS_FILE)
                print(Fore.GREEN + "User IDs cleared successfully!" + Style.RESET_ALL)
            elif clear_choice == "2":
                os.remove(SERVER_LINKS_FILE)
                print(Fore.GREEN + "Server links cleared successfully!" + Style.RESET_ALL)
            elif clear_choice == "3":
                os.remove(ACCOUNTS_FILE)
                os.remove(SERVER_LINKS_FILE)
                print(Fore.GREEN + "Both User IDs and Server links cleared successfully!" + Style.RESET_ALL) 

        elif setup_type == "6":
            accounts = load_accounts()
            server_links = load_server_links()

            print(Fore.CYAN + "Usernames, User IDs, Package Names, and Server Links:" + Style.RESET_ALL)
            for (package_name, user_id), (_, server_link) in zip(accounts, server_links):
                username = get_username(user_id) or user_id
                print(f"Package Name: {package_name}, Username: {username}, User ID: {user_id}, Server Link: {server_link}")

        elif setup_type == "7":
            print(Fore.GREEN + "Auto Setup User IDs from each package's appStorage.json..." + Style.RESET_ALL)
            packages = get_roblox_packages()
            accounts = []

            for package_name in packages:
                file_path = f'/data/data/{package_name}/files/appData/LocalStorage/appStorage.json'
                user_id = find_userid_from_file(file_path)
                
                if user_id:
                    accounts.append((package_name, user_id))
                    print(f"Found UserId for {package_name}: {user_id}")
                else:
                    print(Fore.RED + f"UserId not found for {package_name}. Make sure the file path is correct and the format is as expected." + Style.RESET_ALL)

            save_accounts(accounts)
            print(Fore.GREEN + "User IDs saved from appStorage.json!" + Style.RESET_ALL)

            # Prompt for server link
            server_link = input("Enter the game ID or private server link: ")
            formatted_link = format_server_link(server_link)

            if formatted_link:
                server_links = [(package_name, formatted_link) for package_name in packages]
                save_server_links(server_links)
                print(Fore.GREEN + "Game ID or private server link saved successfully!" + Style.RESET_ALL)

        elif setup_type == "8":
            accounts = load_accounts() 
            server_links = load_server_links()
            accounts = load_accounts() 
            
            if not accounts:
                print(Fore.RED + "No user IDs set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                continue

            # Bypass the user IDs using Delta
            bypassed_links = bypass_user_ids(accounts)

            if not bypassed_links:
                print(Fore.RED + "Failed to bypass user IDs. Please try again." + Style.RESET_ALL)
                continue

            force_rejoin_interval = int(input("Enter the force rejoin/kill Roblox interval in minutes: ")) * 60

            # Kill Roblox processes and wait for 5 seconds
            print("Killing Roblox processes...")
            kill_roblox_processes()
            print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
            time.sleep(5)

            num_packages = len(server_links)  # Count the number of Roblox packages

            for package_name, server_link in server_links:
                launch_roblox(package_name, server_link, num_packages)

            start_time = time.time()

            while True:
                for package_name, user_id in accounts:
                    # Check if the user_id is a number or needs conversion
                    if not user_id.isdigit():
                        print(f"Retrieving user ID for username: {user_id}...")
                        user_id = asyncio.run(get_user_id(user_id))
                        if user_id is None:
                            print(Fore.RED + "Failed to retrieve user ID. Please enter the user ID manually." + Style.RESET_ALL)
                            user_id = input("Enter the user ID: ")

                    # Get the username for display
                    username = get_username(user_id) or user_id

                    # Check online status
                    presence_type = check_user_online(user_id)

                    if presence_type == 2:  # InGame
                        print(Fore.GREEN + f"{username} ({user_id}) is currently in-game." + Style.RESET_ALL)
                    else:
                        print(Fore.RED + f"{username} ({user_id}) is offline or in another status. Checking again..." + Style.RESET_ALL)
                        
                        # Check the user's online status 5 times before rejoining
                        max_retries = 5
                        retry_interval = 3  # 3 seconds delay between checks
                        for attempt in range(max_retries):
                            presence_type = check_user_online(user_id)
                            if presence_type == 2:  # If user is detected as in-game
                                print(Fore.GREEN + f"{username} ({user_id}) is currently in-game." + Style.RESET_ALL)
                                break
                            else:
                                print(Fore.YELLOW + f"Attempt {attempt + 1}/{max_retries}: {username} ({user_id}) is still offline. Retrying in {retry_interval} seconds..." + Style.RESET_ALL)
                                time.sleep(retry_interval)  # Delay between checks

                        if presence_type != 2:  # If the user was offline in all checks
                            print(Fore.RED + f"{username} ({user_id}) is offline. Rejoining..." + Style.RESET_ALL)
                            kill_roblox_process(package_name)
                            launch_roblox(package_name, server_link, num_packages)

                    # Introduce a delay between checking each user to prevent spamming
                    time.sleep(5)  # Adjust the delay time as needed

                time.sleep(60)  # Wait 60 seconds before the next check
                
                # Check if the script has been running for the specified interval
                if time.time() - start_time >= force_rejoin_interval:
                    print("Force killing Roblox processes due to time limit.")
                    kill_roblox_processes()
                    start_time = time.time()  # Reset start time
                    print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
                    time.sleep(5)
                    # Rejoin all servers after killing the processes
                    for package_name, server_link in server_links:
                        launch_roblox(package_name, server_link, num_packages) 

        if setup_type == "9":
            setup_webhook()

        elif setup_type == "10":
            global stop_webhook_thread
            stop_webhook_thread = True  # Stop the webhook thread if it is running
            break 

if __name__ == "__main__":
    main() 
